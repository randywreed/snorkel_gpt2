# -*- coding: utf-8 -*-
"""gpt2_snorkle_data_labeling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xCtDqqb5b3Hu3Dd7LXdWopSsmic6CUQH

## Setup  
Both snorkel and ktrain require a kernel restart afterwards
install
git+https://github.com/huggingface/transformers.git
snorkel
ktrain
dvc
spacy
nltk
pandas
cython


## Needed files
biblical_names.csv
catholic_terms_rev.csv

dir--hfdedpredictV3
"""

#!pip install --user snorkel

#!pip install --user ktrain

#!pip install --upgrade git+https://github.com/huggingface/transformers.git

#!pip install "dvc[gdrive]"



#from google.colab import drive
#drive.mount('/gdrive')

dirname="/spell/snorkel_files/"
#dirname='/gdrive/My Drive/AI & Tech Research/Religion of GPT2/'
filename='biblical_names.csv'

import pandas as pd
df=pd.read_csv(dirname+filename,delimiter=',')
Bnames=list(df['terms'])

df.head()

filename='catholic_terms_rev.csv'

import pandas as pd
df=pd.read_csv(dirname+filename,delimiter=',')
Cathterms=list(df['terms'])

print(Bnames)

from snorkel.labeling import labeling_function
ABSTAIN=-1
RELIGIOUS=0
SECULAR=1
#FIRST_PER_SG=2
#FIRST_PER_PL=3
#CATHOLICISM=4
#RELIGIONTX=5
#SECULARTX=6

@labeling_function()
def lf_contains_bible_name(x):
  for n in Bnames:
    if str(n).lower() in str(x.text).lower():
      return RELIGIOUS
  return ABSTAIN

@labeling_function()
def lf_contains_bible_quote(x):
  import re
  return RELIGIOUS if re.search(r'\(.+\d*:\d*.+\)',str(x.text)) else ABSTAIN

@labeling_function()
def lf_first_person_sg(x):
  return FIRST_PER_SG if 'I ' in str(x.text) else ABSTAIN

@labeling_function()
def lf_contains_catholicism(x):
  for n in Cathterms:
    if n.lower() in str(x.text).lower():
      return RELIGIOUS
  return ABSTAIN

@labeling_function()
def lf_first_person_pl(x):
  return FIRST_PER_PL if 'we ' in str(x.text).lower() else ABSTAIN

@labeling_function()
def lf_keywords(x):
  keywords=['athiest','athiesm','bible','believe','belief','spiritual','spirtuality','magic']
  return RELIGIOUS if any(word in x.text.lower() for word in keywords) else ABSTAIN

from transformers import pipeline
classifier=pipeline('zero-shot-classification')

@labeling_function()
def lf_0shot_model(x):
  candidate_labels = ["religious", "secular"]
  candidate_results = [0, 0]
  res = classifier(x.text, candidate_labels)
  if res['labels'][0]=='religious' and res['scores'][0]>0.6:
    return RELIGIOUS
  if res['labels'][0]=='secular' and res['scores'][0]>0.6:
    return SECULAR
  return ABSTAIN

import spacy

from snorkel.preprocess import preprocessor
import ktrain
from nltk.tokenize import sent_tokenize
import nltk
nltk.download('punkt')
from statistics import mean
predictor=ktrain.load_predictor(dirname+'hfdedpredictV3')
def flmean(x):
    sum=0
    for ele in x:
        sum+=ele
    res=sum/len(x)
    return res


@preprocessor(memoize=True)
def bert_religion_classifier(x):
  sents=sent_tokenize(str(x.text))
  #sentC=[]
  sentR=[]
  sentS=[]
  for sent in sents:
    #sentC.append(predictor.predict(sent))
    p=predictor.predict_proba(str(sent))
    sentR.append(p[0])
    sentS.append(p[1])
  print('sentR={} sentS={}'.format(sentR,sentS))
  if len(sentR)>1:
    R=flmean(sentR)
  else: 
    R=sentR[0]
  if len(sentS)>1:
    S=flmean(sentS)
  else:
    S=sentS[0]
  if R>S:
    x.cat='R'
  else:
    x.cat='S'
  #x.cat=predictor.predict(x.text)
  return x

@labeling_function(pre=[bert_religion_classifier])
def lf_bert_religion(x):
  return RELIGIOUS if x.cat=="R" else ABSTAIN

@labeling_function(pre=[bert_religion_classifier])
def lf_bert_secular(x):
  return SECULAR if x.cat=="S" else ABSTAIN

from snorkel.labeling import LabelingFunction


def keyword_lookup(x, keywords, label):
    try:
      if any(word in x.text.lower() for word in keywords):
          return label
      return ABSTAIN
    except Exception:
      return ABSTAIN

def make_keyword_lf(keywords, label=RELIGIOUS):
    return LabelingFunction(
        name=f"keyword_{keywords[0]}",
        f=keyword_lookup,
        resources=dict(keywords=keywords, label=label),
    )

keyword_bible=make_keyword_lf(keywords=['bible','biblical'])
keyword_belief=make_keyword_lf(keywords=['believe', 'belief'])
keyword_jesus=make_keyword_lf(keywords=['Jesus','christ'])
keyword_atheism=make_keyword_lf(keywords=['atheist','atheism','atheists','atheistic'])
keyword_spiritual=make_keyword_lf(keywords=['spiritual','spirituality'])
keyword_magic=make_keyword_lf(keywords=['magic'])
keyword_mythology=make_keyword_lf(keywords=['zeus','hera','apollo','hermes','myth','mythology','pagan','paganism'])
keyword_creation=make_keyword_lf(keywords=['creator','created','creation'])

"""## apply labeler"""

#!ls

import pandas as pd
#filename='dedoose_GPT2 Initial prompts and responses.csv'
filename='gpt2HfDedPredictBertv3short.csv'
df=pd.read_csv(filename,error_bad_lines=False)
#df.columns=['participant','group','prompt','resp','question','text'] #dedoose gpt2 prompts and responses
df.head()

bad_col=df.columns[0]
df.drop([bad_col],axis=1,inplace=True)
df.rename(columns={'Text':'text'},inplace=True)
train=df.sample(frac=0.8,random_state=200)
test=df.drop(train.index)

train.head()

test.Orig_Cat.value_counts()

test['Orig_Cat']=test['Orig_Cat'].replace(to_replace="R", value=0)
test['Orig_Cat']=test['Orig_Cat'].replace(to_replace="S", value=1)
Ytest=test.Orig_Cat.values

Ytest

print(df.columns[0])
df.head()

#from google.colab import auth
#auth.authenticate_user()

#import gspread
#from oauth2client.client import GoogleCredentials

#gc = gspread.authorize(GoogleCredentials.get_application_default())

#

# get_all_values gives a list of rows.

#worksheet=gc.open_by_url('https://docs.google.com/spreadsheets/d/1cPYRaels5ahcPk_4oTXGvwv-7Tv4NAkChaae6IDMz6o/edit#gid=1281155805').sheet1
#rows = worksheet.get_all_values()
#print(rows)

# Convert to a DataFrame and render.
#import pandas as pd
#df=pd.DataFrame.from_records(rows)

train.head()

from snorkel.labeling import PandasLFApplier
lfs=[lf_contains_bible_name, 
     lf_contains_bible_quote, 
     lf_contains_catholicism,
     lf_bert_religion,
     lf_bert_secular,
     keyword_bible,
     keyword_atheism,
     keyword_belief,
     keyword_jesus,
     keyword_magic,
     keyword_mythology,
     keyword_spiritual,
     keyword_creation,
     lf_0shot_model
     ]

applier=PandasLFApplier(lfs=lfs)

Ltrain=applier.apply(df=train)

Ltest=applier.apply(df=test)

#Ltrain[:10]

import numpy as np

np.save('Snorkel_Ltrainv2',Ltrain)
np.save('Snorkel_Ltestv2',Ltest)
np.save('Snorkel_Ytestv2',Ytest)



from snorkel.labeling.model import LabelModel

label_model = LabelModel(cardinality=2, verbose=True)
label_model.fit(L_train=Ltrain, n_epochs=1000, log_freq=100, seed=123)
prob_train=label_model.predict_proba(L=Ltrain)

from snorkel.labeling.model import MajorityLabelVoter

majority_model = MajorityLabelVoter()
preds_train = majority_model.predict(L=Ltrain)

majority_acc = majority_model.score(L=Ltest, Y=Ytest, tie_break_policy="random")[
    "accuracy"
]
print(f"{'Majority Vote Accuracy:':<25} {majority_acc * 100:.1f}%")

label_model_acc = label_model.score(L=Ltest, Y=Ytest, tie_break_policy="random")[
    "accuracy"
]
print(f"{'Label Model Accuracy:':<25} {label_model_acc * 100:.1f}%")

#!ls

label_model.save(dirname+'save_snorkel_label_modelv2.pkl')

"""### if rerunning this start from here"""
'''
from snorkel.labeling.model import LabelModel
label_model=LabelModel(cardinality=2,verbose=True)
label_model.load(dirname+'save_snorkel_label_modelv2.pkl')

import numpy
Ltrain=numpy.loadtxt(dirname+'Snorkel_Ltrainv2.txt')
Ltest=numpy.loadtxt(dirname+'Snorkel_Ltestv2.txt')
Ytest=numpy.loadtxt(dirname+'Snorkel_Ytestv2.txt')

Ltrain[:10]

label_model_acc = label_model.score(L=Ltest, Y=Ytest, tie_break_policy="random")[
    "accuracy"
]
print(f"{'Label Model Accuracy:':<25} {label_model_acc * 100:.1f}%")

train.shape
'''
from snorkel.labeling import filter_unlabeled_dataframe
df_train_filtered, probs_train_filtered = filter_unlabeled_dataframe(X=train, y=prob_train,L=Ltrain)

cnt=0
for a in probs_train_filtered:
  #print(a)
  print(len(a))
  print('{0:.10f}'.format(a[0]))
  print('{0:.10f}'.format(a[1]))
  #print('{0:.10f}'.format(a[2]))
  #print('{0:.10f} {0:.10f} {0:.10f}'.format(a[0],a[1],a[2]))
  cnt+=1
  if cnt>10:
    break

#df_train_filtered

"""### check label model against test set"""
'''
import pandas as pd
tdf=pd.read_pickle(dirname+'dedhf_data_test.pkl')
tdf.rename(columns={'Text':'text'},inplace=True)

tdf.head()

txt=tdf.iloc[1331]['text']
print(txt)

Ltest=applier.apply(df=tdf)

from snorkel.labeling.model import LabelModel

label_model = LabelModel(cardinality=2, verbose=True)
label_model.fit(L_train=Ltest, n_epochs=1000, log_freq=100, seed=123)
prob_train=label_model.predict_proba(L=Ltest)

pdf=pd.DataFrame(prob_train,columns=['R-prob','S-Prob'])

pdf.head()
tdf.reset_index(drop=True,inplace=True)
pdf.reset_index(drop=True, inplace=True)
odf=pd.concat([tdf,pdf],ignore_index=True,axis=1)
odf.columns=['text','orig_cat','Snorkel_R_prob','Snorkel_S_prob']

odf.head()

odf.to_csv('snorkle_test.csv')

import pandas as pd
df=pd.read_csv('snorkle_test.csv')

df.head()

df.drop('Unnamed: 0',axis=1,inplace=True)
df.columns=['text','orig_cat','Snorkel_R_prob','Snorkel_S_prob']

def createNewCat(row):
  #print(row)
  R=row['Snorkel_R_prob']
  S=row['Snorkel_S_prob']
  if R>S:
    if R>.80:
      cat="R+"
    elif R<.60:
      cat="R-"
    else:
      cat="R"
  if R<S:
    if S>.80:
      cat="S+"
    elif R<.60:
      cat="S-"
    else:
      cat="S"
  return cat

df['Snorkel_Cat']=df.apply(lambda row: createNewCat(row), axis=1)

df.Snorkel_Cat.value_counts()

df['Snorkel_Cat'].str[0]

edf=df.loc[~(df['orig_cat']==df['Snorkel_Cat'].str[0])]

edf

edf.to_csv('snorkel_testset_exceptions.csv')


'''


"""### Distilbert Classification model"""

#probs_train_filtered[:10]

#df_train_filtered.head()

print('df_train_filtered')
print(df_train_filtered.head())
print(df_train_filtered.columns)
#df_train_filtered.drop('prob_cat',axis=1)

#add labels to df
df_train_filtered['prob_R']=probs_train_filtered[:,0]
df_train_filtered['prob_S']=probs_train_filtered[:,1]

def addNewCat(row):
  R=row['prob_R']
  S=row['prob_S']
  if R>S:
    return 'R'
  if S>R:
    return 'S'
  return '?'

df_train_filtered['Snokel_Cat']=df_train_filtered.apply(lambda row: addNewCat(row),axis=1)

df_train_filtered.head()

edf=df_train_filtered.loc[~(df_train_filtered['Cat']==df_train_filtered['Snokel_Cat'])]

edf.shape

edf.to_csv('snorkel_errors.csv')

from ktrain import text
train,val,preprocess=text.texts_from_df(df_train_filtered,'text',['prob_R','prob_S'],ngram_range=2,preprocess_mode='distilbert', )

import ktrain
from ktrain import text
MODEL_NAME = 'distilbert-base-uncased'
#t = text.Transformer(MODEL_NAME, maxlen=500, classes=["R","S"])
#trn = t.preprocess_train(x_train, y_train)
#val = t.preprocess_test(x_test, y_test)
model = preprocess.get_classifier()
learner = ktrain.get_learner(model, train_data=train, val_data=val, batch_size=6)

history=learner.autofit(1e-5)

learner.save_model(dirname+"/snorkel/v1/ktrain_trained_model")

predictor = ktrain.get_predictor(learner.model, preproc=preprocess)
predictor.save(dirname+'/snorkel/v1/predictor')